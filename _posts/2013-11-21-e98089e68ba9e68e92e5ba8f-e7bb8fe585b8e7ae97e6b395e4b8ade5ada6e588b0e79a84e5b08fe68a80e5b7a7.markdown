---
author: lufo
comments: true
date: 2013-11-21 09:27:45+00:00
layout: post
slug: '%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f-%e7%bb%8f%e5%85%b8%e7%ae%97%e6%b3%95%e4%b8%ad%e5%ad%a6%e5%88%b0%e7%9a%84%e5%b0%8f%e6%8a%80%e5%b7%a7'
title: 选择排序——经典算法中学到的小技巧
wordpress_id: 115
tags:
- 小Tips
- 编程
---

今天数据结构正好讲到排序，sicily 有个选择排序的题，看了下经典的选择排序，竟学到了小技巧。

原题如下：


<blockquote>

> 
> Description
> 
> 

> 
> 

排序是一种必不可少的工具，生活工作中随处可见排序的应用。例如，平日我们整理文档的时候难免要按序号排序，现在用选择排序方法来解决问题。选择排序的方法是，将大小为 N 的数组分成 S 和 U 两个部分，代表已经排序和未排序的部分。每次操作均从 U 中挑选一个最小元素，跟 U 中的第一个元素交换，随后将 U 中的第一个元素归入 S 中。即，每次操作结束后 S 将增加一个元素，U 将减少一个元素。做完 (N-1) 次操作即可完成整个选择排序。如此实用的方法，大家动手尝试下吧。


> 
> 

> 
> Input
> 
> 

> 
> 

可能有多个测试输入，第一行给出总共的测试输入的个数。

对于每个测试输入，第一行包含一个正整数 N，第二行包含一个大小为 N 的无序数组 (0<N<1000)。


> 
> 

> 
> Output
> 
> 

> 
> 

输出每次数组做选择排序得到的结果，共计 (N-1) 行数据。数据之间用一个空格隔开，行末不能有多余的空格。


> 
> 

> 
> Sample Input
> 
> 

> 
>  Copy sample input to clipboard
> 
> 

> 
> 

>     
>     1
>     5
>     2 5 4 1 3
> 
> 

> 
> 

> 
> Sample Output
> 
> 

> 
> 

>     
>     1 5 4 2 3
>     1 2 4 5 3
>     1 2 3 5 4
>     1 2 3 4 5
> 
> 

> 
> 

> 
> ### Problem Source: 2012 年期末机考（Pan）
> 
> 
</blockquote>


这题其实很简单，但有一个细节是算法在寻找最小值时，寻找的是数组中**最小值的下标**，而不是数组中最小的值，这样做的好处显而易见：**可以通过下标找到最小值，但通过最小值找下表则要循环查找，很费时间**，而我以前经常做这种通过最小值循环找下标的傻事，以后可长心了。

代码如下：

[cpp]

#include <iostream>
using namespace std;

int main() {
 int n, m, i, j, min;
 cin >> n;
 while (n--) {
 cin >> m;
 int a[m];
 for (i = 0; i < m; i++)
 cin >> a[i];
 for (i = 0; i < m; i++) {
 min = i;
 for (j = i + 1; j < m; j++) {
 if (a[j] < a[min])
 min = j;
 }
 int temp = a[i];
 a[i] = a[min];
 a[min] = temp;
 if (i != m - 1) {
 for (j = 0; j < m - 1; j++) {
 cout << a[j] << " ";
 }
 cout << a[m - 1] << endl;
 }
 }
 }
 return 0;
}

[/cpp]

---
title: 网易游戏面试总结
layout: post
tags:
  - daily
  - python
---
![](/media/files/2015/04/06.jpg)

刚刚面完网易游戏一面,先说下感受:这是我不多的面试经历中最虐的一次,不愧是网易游戏.首先很正式,面试之前都是 hr 联系的我,面试时有两个面试官,然后问题真的很虐,深度明显高出 BAT 一截,下面仔细说一下关于 Python 的一些问题.

网易游戏面 python 其实让我挺吃惊,也不得不说面的很有水平,让我意识到我 python 远远没有达到熟悉的程度.举两题为例:

	a=1
	b=1
	a is b
	a=1.1
	b=1.1
	a is b
	
a is b 返回什么?is 判断的是两个变量指向的地址是否相等,而在 python 中一切皆对象, 首先要了解 python 中的 object,关于 object [python 官方文档](https://docs.python.org/2/reference/datamodel.html)是这么说的:

>Objects are Python’s abstraction for data. All data in a Python program is represented by objects or by relations between objects. (In a sense, and in conformance to Von Neumann’s model of a “stored program computer,” code is also represented by objects.)
	
>Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is‘ operator compares the identity of two objects; the id() function returns an integer representing its identity (currently implemented as its address). An object’s type is also unchangeable. [1] An object’s type determines the operations that the object supports (e.g., “does it have a length?”) and also defines the possible values for objects of that type. The type() function returns an object’s type (which is an object itself). The value of some objects can change. Objects whose value can change are said to be mutable; objects whose value is unchangeable once they are created are called immutable. (The value of an immutable container object that contains a reference to a mutable object can change when the latter’s value is changed; however the container is still considered immutable, because the collection of objects it contains cannot be changed. So, immutability is not strictly the same as having an unchangeable value, it is more subtle.) An object’s mutability is determined by its type; for instance, numbers, strings and tuples are immutable, while dictionaries and lists are mutable.

>Objects are never explicitly destroyed; however, when they become unreachable they may be garbage-collected. An implementation is allowed to postpone garbage collection or omit it altogether — it is a matter of implementation quality how garbage collection is implemented, as long as no objects are collected that are still reachable.
	
大概是说每个 object有三个属性:id(可以理解为内存地址),type(整形,字符串等等,决定这个对象有哪些方法),值. 对于一个对象,它的id 和 type是不变的,而有些对象的 value 是可变的(dict,list),有些是不可变的(int,string),关于这一点之后会详细讨论.

再回到之前的问题,a=1.1实际上是把1.1这个对象的地址赋给 a,b=1.1又新建了一个对象将它的地址赋给 b,为什么不直接把之前那个对象的地址赋给 b 呐?我猜测是因为判断现在有没有1.1这个对象存在开销较大(如有错误欢迎指正),所以 a is b返回False.有趣的是第一个 a is b 返回的是 True,现在问题来了,为什么第一个是 True
?python 为了减少 malloc 的开销,为常用的整数[-5~257)开辟了一块小内存进行缓存,所以结果就是这样了.下面是第二个问题:

    def test(a):
        a='hello'
    
    def main():
        b='world'
        test(b)

请问最后 b 是什么,答案是'world',这就涉及到 python 的函数参数传递类型和 python 的 object 是否可变的问题.首先要弄懂传值传指针传引用的区别.简单的说传值就是函数新开一个局部变量,把参数的值赋给这个局部变量,传指针也是把参数赋给函数的局部变量,所不同的是参数是指针,穿引用是把参数地址赋给局部变量,并且这个局部变量的值是不能改的,这也就避免了传指针中出现的指针指向未知内存的问题,具体可参考[这里](http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html).

python 中的函数参数传递类似于传指针,在这里 a 只是一个和 b 指向的内容一样的指针,都指向'world',现在要把'world'改为'hello',前面说过 python 的字符串对象的值是不可更改的,所以 a='hello'实际上是改变了 a 的地址,让它指向了'hello'这个对象,所以最后结果b 还是'world'.下面在看一个更改可变对象 list 的例子:

    def test(a):
        a[0]=2
    
    def main():
        b=[1]
        test(b)
        
这样做 b 就会变为[2],但是再看下面这个:

    def test(a):
        a=[2]
    
    def main():
        b=[1]
        test(b)
        
这个 b 最后还是[1],我猜想是 list 的改变是通过改变每个元素所指向的对象改变的 list 的值.list 其实是包含一系列对象的指针,真正可变的是这些指针.

面试还问了一些其他很有趣的问题,如:怎么翻墙,git merge 原理,shell 中'|'的作用等等,总之网易游戏真的很不一样,让我深深意识到自己真实 too young.总之好奇心是第一生产力,over.

参考:

- [python float(0) is 0.0 为什么是 False?](http://www.zhihu.com/question/25334792/answer/30448798)- 
- [从一个“古怪”的case探究CPython对Int对象的实现细节](http://blog.csdn.net/slvher/article/details/44704407)
- [Data model](https://docs.python.org/2/reference/datamodel.html)
- [C/C++语言参数传递----值传递、引用传递、指针传递、指针引用传递](http://blog.csdn.net/whzhaochao/article/details/12891329)
- [C++ 值传递、指针传递、引用传递详解](http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html)
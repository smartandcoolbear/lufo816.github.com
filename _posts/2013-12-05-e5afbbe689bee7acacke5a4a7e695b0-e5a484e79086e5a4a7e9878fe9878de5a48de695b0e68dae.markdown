---
author: lufo
comments: true
date: 2013-12-05 10:12:34+00:00
layout: post
slug: '%e5%af%bb%e6%89%be%e7%ac%ack%e5%a4%a7%e6%95%b0-%e5%a4%84%e7%90%86%e5%a4%a7%e9%87%8f%e9%87%8d%e5%a4%8d%e6%95%b0%e6%8d%ae'
title: 寻找第k大数——处理大量重复数据
wordpress_id: 118
tags:
- 编程
---

<blockquote>

> 
> Description
> 
> 

> 
> 

经过长时间的筹备工作，在Jourk,Ronny,Plipala,阿长,阿沈等人的努力下，DM实验室建立起自己的系列网站，其中包括三个大板块：DMOJ首页、DMOJ论坛、DMOJ博客。

作为一个大型的网站，数据的加工处理需要用到很多算法系统模块，通过这些模块对系统主数据库进行修改。因此，在构建DMOJ系列网站的过程中，编写了一个庞大的数据统计系统，其中包括一个寻找第k大数字的模块，对于一个数据库来说，这样一个模块的重要性不容置疑。但是，由于在修改网站的过程中，这个模块被不慎删掉了，DMOJ找到了聪明的你，希望你能帮DMOJ重写这个模块。

对于输入数据，你将按数据要求找出n个数字中的第k大数字。

关于第k大数字的解释：对于一个数字序列，计算该数字序列第k大数字，一种可行但效率不高的方法是，首先剔除数字序列中重复的数字，然后通过某种排序算法，获得剔除重复数字后的数字序列从大到小排序的数字序列，然后取从大到小排序的数字序列的第k位的数字。从另一个角度，题目中的第k大数字即是不计入数字序列中数字重复出现的部分，对于数字重复出现的情况，应该认为该数字只出现一次。

现在请聪明的你尝试设计一种可行且效率更高的方法来解决这个问题。


> 
> 

> 
> Input
> 
> 

> 
> 

输入数据一共有三行。

第一行有一个正整数n（n<=10000000），表示一共给出多少个数字。

第二行有一个正整数k（k<=10000000），表示要求你找出第k大数字。

第三行有n个整数，给出n个数字。对于每个整数i，均满足-10000000<=i<=10000000。


> 
> 

> 
> Output
> 
> 

> 
> 

    输出文件共一行，包含一个整数，表示n个数字中第k大数字是多少。


> 
> 

> 
> Sample Input
> 
> 

> 
> ![](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAARABIDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAMFBwT/xAAlEAACAQQCAQMFAAAAAAAAAAABAgMABAURBiESIjFBMjZxdbP/xAAYAQACAwAAAAAAAAAAAAAAAAAAAwEEBf/EABsRAQEAAgMBAAAAAAAAAAAAAAEAAgMEEyFh/9oADAMBAAIRAxEAPwDQeRW+SyVnctBIkiiScOk87qm0ciP0aZWA8dkEDZA2fcGPCWPI+PXkUt3GIcQjkyQxTGdtMrAhUVQO5CraVd/UB1pa7cnHmbaW5hjxEktoZJJGulnjChWYsT4lvLoHvr3B1vommvuQYaSe/jGSxrW9yXEiCWIiTe9eWohvs/LH8n5ocDh9jlnsER+zt+9wDE9G0uKWO4hSaGRJIpFDI6MCrKewQR7ilVfFPs7B/r4P5rStB8ZJW9KUqIlKUoi//9k=) Copy sample input to clipboard
> 
> 

> 
> 

>     
>     3
>     2
>     2006 2007 2008
> 
> 

> 
> 

> 
> Sample Output
> 
> 

> 
> 

>     
>     2007
> 
> 

> 
> </blockquote>


这个题真是坑！首先想到先排序再找第k大不重复的数，但一直TLE，想了好几天不用排序的方法一直想不出来，今天终于发现了问题所在，原来都是cin的问题！**cin cout 效率比scanf printf差好多**，改过来之后就AC了，代码如下：

[cpp]
<pre>#include <iostream>
#include <cstdio>
using namespace std;

int s[10000000];

void qsort(int l, int r) {
    int i, j, x;
    if (l < r) {
        i = l;
        j = r;
        x = s[i];
        while (i < j) {
            while (i < j && s[j] < x)
                j--; /* 从右向左找第一个大于x的数 */
            if (i < j)
                s[i++] = s[j];
            while (i < j && s[i] > x)
                i++; /* 从左向右找第一个小于x的数 */
            if (i < j)
                s[j--] = s[i];
        }
        s[i] = x;
        qsort( l, i - 1); /* 递归调用 */
        qsort(i + 1, r);
    }
}
int main() {
    int n, k, i;
    scanf("%d%d",&n,&k);
    for (i = 0; i < n; i++) {
        scanf("%d",&s[i]);
    }
    qsort( 0, n - 1);
    int max = s[0];
    if (k == 1) {
        printf("%d\n",max);
    }
    for (i = 1; i < n; i++) {
        if (max > s[i]) {
            k--;
            max = s[i];
        }
        if (k == 1) {
            printf("%d\n",max);
            break;
        }
    }
    return 0;
}</pre>
[/cpp]

另外TA也讲了不用排序的算法，真是处理重复数据的神器，代码如下：

[cpp]

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

const int maxn=10000000;

int N,K;
bool tag[maxn*2+1];//标示位

int main()
{
 scanf("%d%d",&N,&K);
 memset(tag,0,sizeof(tag));
 for(int i=0;i<N;i++){
 int tmp;
 scanf("%d",&tmp);
 tag[tmp+maxn]=1;//标示tag位
 }
 int sum=0;
 for(int i=maxn*2;i>=0;i--){
 if(sum+tag[i]==K){
 printf("%d\n",i-maxn);
 break;
 }
 sum+=tag[i];
 }
 return 0;
}

[/cpp]

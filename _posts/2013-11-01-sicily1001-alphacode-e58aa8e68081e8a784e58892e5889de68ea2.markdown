---
author: lufo
comments: true
date: 2013-11-01 02:08:13+00:00
layout: post
slug: sicily1001-alphacode-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e5%88%9d%e6%8e%a2
title: Sicily1001. Alphacode 动态规划初探
wordpress_id: 81
tags:
- algorithm
---

<blockquote>

> 
> # Constraints
> 
> 
Time Limit: 1 secs, Memory Limit: 32 MB

> 
> # Description
> 
> 
Alice and Bob need to send secret messages to each other and are discussing ways to encode their messages: Alice: "Let's just use a very simple code: We'll assign `A' the code word 1, `B' will be 2, and so on down to `Z' being assigned 26." Bob: "That's a stupid code, Alice. Suppose I send you the word `BEAN' encoded as 25114. You could decode that in many different ways!" Alice: "Sure you could, but what words would you get? Other than `BEAN', you'd get `BEAAD', `YAAD', `YAN', `YKD' and `BEKD'. I think you would be able to figure out the correct decoding. And why would you send me the word `BEAN' anyway?" Bob: "OK, maybe that's a bad example, but I bet you that if you got a string of length 500 there would be tons of different decodings and with that many you would find at least two different ones that would make sense." Alice: "How many different decodings?" Bob: "Jillions!" For some reason, Alice is still unconvinced by Bob's argument, so she requires a program that will determine how many decodings there can be for a given string using her code.

> 
> # Input
> 
> 
Input will consist of multiple input sets. Each set will consist of a single line of digits representing a valid encryption (for example, no line will begin with a 0). There will be no spaces between the digits. An input line of `0' will terminate the input and should not be processed

> 
> # Output
> 
> 
For each input set, output the number of possible decodings for the input string. All answers will be within the range of a long variable.

> 
> # Sample Input
> 
> 

>     
>     25114
>     1111111111
>     3333333333
>     0
> 
> 

> 
> # Sample Output
> 
> 

>     
>     6
>     89
>     1
> 
> 
</blockquote>


显然这题应该用递归的方法，于是很快写了出来：

[cpp]

#include<iostream>

using namespace ::std;

int ways(string s, int length) {
 if (length == 1) {
 return 1;
 } else if (length == 0) {
 return 1;
 } else if ((s[length - 2] == '2' && s[length - 1] <= '6')
 || s[length - 2] < '2') {
 return ways(s, length - 1) + ways(s, length - 2);
 } else {
 return ways(s, length - 1);
 }
 }

int main() {
 string s;
 while (cin >> s && s[0] != '0') {
 cout << ways(s, s.length()) << endl;
 }
 return 0;
 }

[/cpp]

提交一看，尼玛超时，这时想起了**动态规划**，把递归得到的每一个项储存起来，下次使用时不用再次计算，用空间换时间。于是有了第二个版本：

[cpp]

#include<iostream>
 using namespace ::std;
 int main() {
 string s;
 int i = 0;
 while (cin >> s && s[0] != '0') {
 int n = s.length();
 int a[n + 1];
 for (i = 0; i <= n; i++)
 a[i] = -1;
 a[0] = 1;
 a[1] = 1;
 for (i = 0; i <= n; i++) {
 if (a[i] == -1) {
 if ((s[i - 2] == '2' && s[i - 1] <= '6') || s[i - 2] < '2') {
 if (s[i - 1] == '0')
 a[i] = a[i - 2];
 else if (s[i - 2] == '0')
 a[i] = a[i - 3];
 else
 a[i] = a[i - 1] + a[i - 2];
 } else {
 a[i] = a[i - 1];
 }
 }
 }
 cout << a[n] << endl;
 }
 return 0;
 }
[/cpp]

这道题的一个坑是对0的处理，搞的我WA了好几次。总之这题是使用动态规划的不错的小例子。

---
author: lufo
comments: true
date: 2013-12-18 15:02:12+00:00
layout: post
slug: 1345-%e8%83%bd%e9%87%8f%e9%a1%b9%e9%93%be-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92
title: 1345. 能量项链 动态规划
wordpress_id: 128
categories:
- 编程
---

<blockquote>

> 
> # Constraints
> 
> 
Time Limit: 1 secs, Memory Limit: 32 MB

> 
> # Description
> 
> 


在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为 （Mars单位），新产生的珠子的头标记为m，尾标记为n。

 需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

 例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：

 (4⊕1)=10*2*3=60。

 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为

 ((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710。









> 
> # Input
> 
> 


输入包含多个测试数据。

每个测试数据的第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i<N时，第i颗珠子的尾标记应该等于第i+1颗珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。





> 
> # Output
> 
> 
对于每个测试数据，输出只有一行，是一个正整数E（E≤2.1*109），为一个最优聚合顺序所释放的总能量。

> 
> # Sample Input
> 
> 

>     
>     4
>     2  3  5  10
>     4
>     2  3  5  10
> 
> 

> 
> # Sample Output
> 
> 

>     
>     710
>     710
> 
> 
</blockquote>


这题想了半天没想出来转换公式，所以上网找了下，代码来自[http://www.cnblogs.com/mjc467621163/archive/2011/07/05/2098645.html](http://www.cnblogs.com/mjc467621163/archive/2011/07/05/2098645.html)

[cpp]
<pre>// 题意: 项链上有N颗能量珠,两颗珠子(m,r)与(r,n)聚合成一颗,释放的能量为m*r*n,
// N颗珠子聚合成一颗,不同的聚合顺序得到的总能量是不同的,求出一串项链释放出的总能量的最大值
// 当N=4, 分别为 (2，3) (3，5) (5，10) (10，2),则最大值是((4⊕1)⊕2)⊕3）=10*2*3+10*3*5+10*5*10=710

#include<iostream>            //DP
#include<cstring>
using namespace std;
int n,num[210][2],dp[210][210];
// dp[i][j]表示 i 条项链,以 项链 j 作结束 的最大能量值,由项链(j-i+1...j)组成
int main()
{
    while(cin>>n)
    {
        for(int i=1;i<=n;++i)
            cin>>num[i][0];
        for(int i=1;i<=n;++i)    //样例中,num[1-8]=(2,3),(3,5),(5,10),(10,2),(2,3),(3,5),(5,10),(10,2)
        {    
            if(i==n)
                num[i][1]=num[1][0];
            else
                num[i][1]=num[i+1][0];
            num[i+n][0]=num[i][0];
            num[i+n][1]=num[i][1];
        }    
        memset(dp,0,sizeof(dp));    
        for(int i=2;i<=n;++i)        //i从2开始,因为只有一条项链时,能量值自然是0
            for(int j=i;j<2*n;++j)
            {
                for(int k=j-i+1;k<j;++k)    
                    dp[i][j]= max( dp[i][j] , dp[k-j+i][k] + dp[j-k][j] + num[j-i+1][0] * num[k][1] * num[j][1] );
            }
        // dp[i][j] 由 项链(j-i+1...k) 和 (k+1...j) 组成,其中 j-i+1 <= k <= j-1
        // 而 (j-i+1...k) 表示成 dp[k-j+i][k] , (k+1...j) 表示 dp[j-k][j],
        // 能量的聚合值: ⊕= num[j-i+1][0] * num[k][1] * num[j][1]        

        int ans=0;
        for(int i=n;i<2*n;++i)    // 最优解是以第i条项链作为结束的n条项链所释放的能量的最大值 
        {
            ans=max(ans,dp[n][i]);
        }
        cout<<ans<<endl;
    }
    return 0;
}</pre>
[/cpp]

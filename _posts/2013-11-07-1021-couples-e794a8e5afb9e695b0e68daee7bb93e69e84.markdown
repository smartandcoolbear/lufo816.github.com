---
author: lufo
comments: true
date: 2013-11-07 12:55:32+00:00
layout: post
slug: 1021-couples-%e7%94%a8%e5%af%b9%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84
title: 1021. Couples 用对数据结构
wordpress_id: 98
tags:
- 编程
---

<blockquote>

> 
> # Constraints
> 
> 
Time Limit: 1 secs, Memory Limit: 32 MB

> 
> # Description
> 
> 
N couples are standing in a circle, numbered consecutively clockwise from 1 to 2N. Husband and wife do not always stand together. We remove the couples who stand together until the circle is empty or we can't remove a couple any more.

Can we remove all the couples out of the circle?

> 
> # Input
> 
> 
There may be several test cases in the input file. In each case, the first line is an integer **N**(1 <= N <= 100000)----the number of couples. In the following N lines, each line contains two integers ---- the numbers of each couple.
N = 0 indicates the end of the input.

> 
> # Output
> 
> 
Output "**Yes**" if we can remove all the couples out of the circle. Otherwise, output "**No**".

> 
> # Sample Input
> 
> 

>     
>     4
>     1 4
>     2 3
>     5 6
>     7 8
>     
>     2
>     1 3
>     2 4
>     
>     0
> 
> 

> 
> # Sample Output
> 
> 

>     
>     Yes
>     No
> 
> 

> 
> # Problem Source
> 
> 
ZSUACM Team Member</blockquote>


这题坑了我两个多小时，开始一直在用双向链表做，实在麻烦，后来改用数组。其实算法很简单，就是不容易想到，还有就是我一直非常二逼想用一个二维数组记录位置和情侣关系，其实**数组的编号和内容足以记录两组信息**。给每对情侣赋一个唯一的值，与栈顶元素比较，如果是情侣则弹出栈顶元素，不是则弹入。至于有人问因为是围成一个圈，所以第一个元素为什么不用和最后一个比较。其实如果答案是Yes，那么中间的元素肯定最后都不在栈中，第一个和最后一个自然能比较了。代码：

[cpp]

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
using namespace std ;

int couple[200005] ;

int main()
{
 int n ;
 while(cin >> n && n)
 {
 int a, b ;
 for(int i = 1 ; i <= n ; i ++)
 {
 scanf("%d %d",&a,&b) ;
 couple[a] = couple[b] = i ;
 }
 stack<int> s ;

for(int i = 1 ; i <= 2*n ; i ++)
 {
 if( s.empty () || s.top() != couple[i])
 s.push (couple[i]) ;
 else
 s.pop () ;
 }
 if(s.size () > 0) printf("No\n") ;
 else printf("Yes\n") ;
 }
}

[/cpp]

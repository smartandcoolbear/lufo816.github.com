---
author: lufo
comments: true
date: 2013-12-17 15:15:39+00:00
layout: post
slug: 1218-%e7%ba%aa%e5%bf%b5%e9%82%ae%e7%a5%a8-%e5%b0%bd%e9%87%8f%e9%99%8d%e4%bd%8e%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6
title: 1218. 纪念邮票 尽量降低时间复杂度
wordpress_id: 125
categories:
- 编程
---

<blockquote>

> 
> Description
> 
> 

> 
> 

邮局最近推出了一套特殊的纪念邮票，这套邮票共有N张，邮票面值各不相同，按编号顺序为1分，2分，．．．．．．，N分。

小杭是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有M分，并不够把全套都买下。他希望尽量买，最好刚好花光所有钱。作为一个集邮爱好者，小杭也不想买的邮票编号断断续续。所以小杭打算买面值a分至b分的b-a+1张连续的邮票，且总价值刚好为M分。

你的任务是求出所有符合要求的方案，以[a,b]的形式输出。


> 
> 

> 
> Input
> 
> 

> 
> 

输入文件只有一行，包含两个数N和M（1<=N，M<=109）。


> 
> 

> 
> Output
> 
> 

> 
> 

输出文件每行包含一个合法方案：[a,b]。按a值从小到大输出。

输出文件不含任何空格。


> 
> 

> 
> Sample Input
> 
> 

> 
>  Copy sample input to clipboard
> 
> 

> 
> 

>     
>     20 15
> 
> 

> 
> 

> 
> Sample Output
> 
> 

> 
> 

>     
>     [1,5]
>     [4,6]
>     [7,8]
>     [15,15]
> 
> 

> 
> </blockquote>


开始写了个时间复杂度为m的，结果还TLE，看了下别人的，原来能降到根号m，对数据观察要仔细，尽量降低复杂度。

[cpp]

#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

int main() {
 int m, n, i, l;
 scanf("%d%d", &n, &m);
 for (i = sqrt(m * 2 + 1); i >= 1; i--) {
 if ((m * 2) % i == 0) {
 if (m % i == 0) {
 if (i % 2 != 0) {
 l = (i - 1) / 2;
 if (m / i - l > 0 && m / i + l <= n) {
 printf("[%d,%d]\n", m / i - l, m / i + l);
 }
 }
 } else {
 if (i % 2 == 0) {
 l = i / 2;
 if ((m * 2 / i - 2 * l + 1) / 2 > 0
 && (m * 2 / i + 2 * l - 1) / 2 <= n) {
 printf("[%d,%d]\n", (m * 2 / i - 2 * l + 1) / 2,
 (m * 2 / i + 2 * l - 1) / 2);
 }
 }
 }
 }
 }
 return 0;
}

[/cpp]
